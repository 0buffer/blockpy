
/**
 * An automatically generated file, based on the files in `instructors/`.
 * We need to have the python code in these files made available in the 
 * JS files, so we load them in via a preprocessing step.
 */

var $INSTRUCTOR_MODULES_EXTENDED = {};

$INSTRUCTOR_MODULES_EXTENDED["instructor_append.py"] = "from instructor_utility import *\ndef append_group_on_change():\n    wrong_not_append_to_list()\ndef append_group():\n    missing_append_in_iteration()\n    wrong_not_append_to_list()\n    missing_append_list_initialization()\n    wrong_append_list_initiatization()\n    append_list_wrong_slot()\ndef find_append_in(node):\n    appendList = []\n    calls = node.find_all(\"Call\")\n    for node in calls:\n        if node.func.attr == \"append\":\n            appendList.append(node)\n    return appendList\ndef missing_append_in_iteration():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    for loop in for_loops:\n        if len(find_append_in(loop)):\n            return False\n    explain(\"You must construct a list by appending values one at a time to the list.<br><br><i>(app_in_iter)<i></br>\")\n    return True\ndef wrong_not_append_to_list():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    for loop in for_loops:\n        append_nodes = find_append_in(loop)\n        for node in append_nodes:\n            listNode = node.func.value\n            if listNode.data_type != \"List\":\n                explain(\"Values can only be appended to a list. The property <code>%s</code> is either not initialized, not initialized correctly, or is confused with another property.<br><br><i>(app_not_list)<i></br>\" %(listNode.id))\ndef missing_append_list_initialization():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    loop_appends = []\n    for loop in for_loops:\n        loop_appends.extend(find_append_in(loop));\n    assignments = ast.find_all(\"Assign\")\n    for append_call in loop_appends:\n        append_loc = append_call.lineno\n        append_var = append_call.func.value\n        found_init = False\n        for assignment in assignments:\n            if assignment.has(append_var) and assignment.lineno < append_loc:\n                found_init = True\n                break\n        if found_init == False:\n            explain(\"The list property <code>%s</code> must be initialized.<br><br><i>(no_app_list_init)<i></br>\" %(append_var.id))\n            return True\n    return False\n\ndef wrong_append_list_initiatization():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    loop_appends = []\n    for loop in for_loops:\n        loop_appends.extend(find_append_in(loop));\n    assignments = ast.find_all(\"Assign\")\n    for append_call in loop_appends:\n        append_loc = append_call.lineno\n        append_var = append_call.func.value\n        init_fail = False\n        for assignment in assignments:\n            if assignment.has(append_var) and assignment.lineno < append_loc:\n                if assignment.value.ast_name == \"List\":\n                    if len(assignment.value.elts) != 0:\n                        init_fail = True\n                else:#or if its not even a list\n                    init_fail = True\n            if init_fail:\n                explain(\"The list property <code>%s</code> is not initialized correctly.<br><br><i>(app_list_init)<i></br>\" %(append_var.id))\n                return\ndef append_list_wrong_slot():\n    ast = parse_program()\n    append_calls = find_append_in(ast)\n    for append_call in append_calls:\n        arg = append_call.args[0]\n        caller = append_call.func.value\n        if arg.ast_name == \"Name\":\n            if arg.data_type == \"List\":\n                explain(\"You should not append a list (<code>%s</code>) to <code>%s</code>.<br><br><i>(app_list_slot)<i></br>\" %(arg.id, caller.id))"
$INSTRUCTOR_MODULES_EXTENDED["instructor_filter.py"] = "from instructor_utility import *\ndef filter_group():\n    missing_if_in_for()\n    append_not_in_if()\n'''\nName: missing_if_in_for\nPattern:\nmissing\nfor <item> in ___ :\n    if …<item> … :\n\nFeedback: The arrangement of decision and iteration is not correct for the filter pattern.\n\n'''\ndef missing_if_in_for():\n    ast = parse_program()\n    loops = ast.find_all(\"For\")\n    for loop in loops:\n        iter_prop = loop.target\n        ifs = loop.find_all(\"If\")\n        for if_block in ifs:\n            if if_block.has(iter_prop):\n                return False\n    explain(\"The arrangement of decision and iteration is not correct for the filter pattern.<br><br><i>(missing_if_in_for)<i></br>\")\n    return True\n'''\nName: append_not_in_if\nPattern:\nmissing\nif … :\n   ___.append(___)\n\nFeedback: Only items satisfying some condition should be appended to the list.\n\n'''\ndef append_not_in_if():\n    ast = parse_program()\n    ifs = ast.find_all(\"If\")\n    for if_block in ifs:\n        calls = if_block.find_all(\"Call\")\n        for node in calls:\n            if node.func.attr == \"append\":\n                return False\n    explain(\"Only items satisfying some condition should be appended to the list.<br><br><i>(app_not_in_if)<i></br>\")\n    return True"
$INSTRUCTOR_MODULES_EXTENDED["instructor_functions.py"] = "from instructor import *\n\nDELTA = 0.001\n\ndef match_signature(name, length, *parameters):\n    ast = parse_program()\n    defs = ast.find_all('FunctionDef')\n    for a_def in defs:\n        if a_def._name == name:\n            found_length = len(a_def.args.args)\n            if found_length < length:\n                gently(\"The function named <code>{}</code> has fewer parameters ({}) than expected ({}).\".format(name, found_length, length))\n            elif found_length > length:\n                gently(\"The function named <code>{}</code> has more parameters ({}) than expected ({}).\".format(name, found_length, length))\n            elif parameters:\n                for parameter, arg in zip(parameters, a_def.args.args):\n                    if arg.id != parameter:\n                        gently(\"Error in definition of <code>{}</code>. Expected a parameter named {}, instead found {}.\".format(name, parameter, arg.id))\n                else:\n                    return a_def\n            else:\n                return a_def\n    else:\n        gently(\"No function named <code>{}</code> was found.\".format(name))\n    return None\n    \ndef unit_test(name, *tests):\n    if name in student.data:\n        the_function = student.data[name]\n        if callable(the_function):\n            for test in tests:\n                inp = test[:-1]\n                out = test[-1]\n                tip = \"\"\n                if isinstance(out, tuple):\n                    tip = \"<br><br>\"+out[1]\n                    out = out[0]\n                message = \"Your <code>{}</code> function did not produce the correct output for the values {}.<br>Expected: <code>{}</code><br>Actual: <code>{}</code>{}\"\n                test_out = the_function(*inp)\n                message = message.format(name, ', '.join([\"<code>{}</code>\".format(repr(i)) for i in inp]), repr(out), repr(test_out), tip)\n                if (isinstance(out, float) and \n                    isinstance(test_out, (float, int)) and\n                    abs(out-test_out) < DELTA):\n                    continue\n                elif out != test_out:\n                    gently(message)\n                    return None\n            else:\n                return the_function\n        else:\n            gently(\"You defined {}, but did not define it as a function.\".format(name))\n            return None\n    else:\n        gently(\"The function <code>{}</code> was not defined.\".format(name))\n        return None"
$INSTRUCTOR_MODULES_EXTENDED["instructor_histogram.py"] = "from instructor_utility import *\ndef histogram_group():\n    histogram_argument_not_list()\n    histogram_missing()\n    plot_show_missing()\n    histogram_wrong_list()\n'''\nName: histogram_missing\nPattern:\n\nMissing\n   plt.hist(___)\n\nFeedback: The program should display a histogram.\n\n'''\ndef histogram_missing():\n    ast = parse_program()\n    calls = ast.find_all(\"Call\")\n    plotting = False\n    for call in calls:\n        if call.func.attr == \"hist\" and call.func.value.id == \"plt\":\n            plotting = True\n            break\n    if plotting == False:\n        explain(\"The program should display a histogram.<br><br><i>(histo_missing)<i></br>\")\n    return not plotting\n'''\nName: plot_show_missing\nPattern:\nMissing\n   plt.show()\n\nFeedback: The plot must be explicitly shown to appear in the Printer area.\n'''\ndef plot_show_missing():\n    ast = parse_program()\n    calls = ast.find_all(\"Call\")\n    plotting = False\n    for call in calls:\n        if call.func.attr == \"show\" and call.func.value.id == \"plt\":\n            plotting = True\n            break\n    if plotting == False:\n        explain(\"The plot must be explicitly shown to appear in the Printer area.<br><br><i>(plot_show_missing)<i></br>\")\n    return not plotting\n'''\nName: histogram_argument_not_list\nPattern:\n   plt.hist(<argument>)\nWhere type(<argument>) is not “list”\n\nFeedback: Making a histogram requires a list; <argument> is not a list.\n\n'''\ndef histogram_argument_not_list():\n    ast = parse_program()\n    calls = ast.find_all(\"Call\")\n    arg_name = \"\"\n    for call in calls:\n        if call.func.attr == \"hist\" and call.func.value.id == \"plt\":\n            arg = call.args[0]\n            if arg != None and not (arg.data_type == \"List\" or arg.ast_name == \"List\"):\n                arg_name = arg.id\n                break\n    if arg_name != \"\":\n        if arg_name == \"___\":\n            explain(\"Making a histogram requires a list.<br><br><i>(hist_arg_not_list_blank)<i></br>\")\n        else:\n            explain(\"Making a histogram requires a list; <code>%s</code> is not a list.<br><br><i>(hist_arg_not_list)<i></br>\" %(arg_name))\n    return arg_name != \"\"\n'''\nName: histogram_wrong_list\nPattern:\n\nfor ___ in ___:\n   <target>.append(___)\nplt.hist(<list>)\n\nwhere name(<target>) != name(<list>)\n\nFeedback: The list created in the iteration is not the list being used to create the histogram.\n\n'''\n\ndef histogram_wrong_list():\n    ast = parse_program()\n    loops = ast.find_all(\"For\")\n    append_targets = []\n    for loop in loops:\n        calls = loop.find_all(\"Call\")\n        for call in calls:\n            if call.func.attr == \"append\":\n                append_targets.append(call.func.value)\n    all_proper_plot = True\n    #should probably actually check for the location of plt.hist\n    calls = ast.find_all(\"Call\")\n    for call in calls:\n        if call.func.attr == \"hist\" and call.func.value.id == \"plt\":\n            arg = call.args[0]\n            proper_plot = False\n            if arg.ast_name == \"Name\":\n                for name in append_targets:\n                    if name.id == arg.id:\n                        proper_plot = True\n                        break\n                if not proper_plot:\n                    all_proper_plot = False\n                    break\n            else:\n                all_proper_plot = False\n                break\n    if not all_proper_plot:\n        explain(\"The list created in the iteration is not the list being used to create the histogram.<br><br><i>(histo_wrong_list)<i></br>\")\n    return not all_proper_plot"
$INSTRUCTOR_MODULES_EXTENDED["instructor_iteration.py"] = "from instructor import *\ndef iteration_group():\n    wrong_target_is_list()\n    wrong_list_repeated_in_for()\n    missing_iterator_initialization()\n    wrong_iterator_not_list()\n    missing_target_slot_empty()\n    list_not_initialized_on_run()\n    list_initialization_misplaced()\n    missing_for_slot_empty()\ndef iteration_group_on_change():\n    wrong_target_is_list()\n    wrong_list_repeated_in_for()\n    wrong_iterator_not_list()\ndef all_for_loops():\n    ast = parse_program()\n    return ast.find_all(\"For\")\n#this conflics with list_repeated_in_for\ndef wrong_target_is_list():\n    for_loops = all_for_loops()\n    for loop in for_loops:\n        iter_prop = loop.target\n        if iter_prop.ast_name == \"Name\" and iter_prop.data_type == \"List\":\n            explain('The property <code>%s</code> is a list and should not be placed in the iteration property slot of the \"for\" block<br><br><i>(target_is_list)<i></br>.' % (iter_prop.id))\n    return False\n#this conflics with list_in_wrong_slot_in_for\ndef wrong_list_repeated_in_for():\n    for_loops = all_for_loops()\n    for loop in for_loops:\n        iter_prop = loop.target\n        list_prop = loop.iter\n        if iter_prop.ast_name == \"Name\" and list_prop.ast_name == \"Name\" and iter_prop.id == list_prop.id and iter_prop.data_type == \"List\":\n            explain('The <code>%s</code> property can only appear once in the \"for\" block <br><br><i>(list_repeat)<i></br>' % (list_prop.id))\n    return False\n#this isn't consistent with the pattern you wrote\ndef missing_iterator_initialization():\n    ast = parse_program()\n    for_loops = all_for_loops()\n    for loop in for_loops:\n        list_prop = loop.iter\n        if list_prop.ast_name != \"List\" and (list_prop.data_type != \"List\" or def_use_error(list_prop)):\n            if list_prop.id == \"___\":\n                explain(\"The slot to hold a list in the iteration is empty.<br><br><i>(no_iter_init-blank)<i></br>\" %(list_prop.id))\n            else:\n                explain(\"The property <code>%s</code> is in the list slot of the iteration but is not a list.<br><br><i>(no_iter_init)<i></br>\" %(list_prop.id))\n            return True\n    return False\n#TODO: We need to cover the different cases for these\ndef wrong_iterator_not_list():\n    for_loops = all_for_loops()\n    for loop in for_loops:\n        list_prop = loop.iter\n        if list_prop.ast_name != \"List\" and list_prop.data_type != \"List\" and list_prop.id != \"___\":\n            if list_prop.ast_name == \"Name\":\n                explain(\"The property <code>%s</code> has been set to something that is not a list but is placed in the iteration block that must be a list.<br><br><i>(iter_not_list)<i></br>\" % (list_prop.id))\n                return True\n    return False\ndef missing_target_slot_empty():\n    for_loops = all_for_loops()\n    for loop in for_loops:\n        iter_prop = loop.target\n        if iter_prop.id == \"___\":\n            explain(\"You must fill in the empty slot in the iteration.<br><br><i>(target_empty)<i></br>\")\n            return True\n    return False\ndef list_not_initialized_on_run():\n    for_loops = all_for_loops()\n    for loop in for_loops:\n        list_prop = loop.iter\n        if list_prop.data_type == None:\n            explain(\"The list in your for loop has not been initialized<br><br><i>(no_list_init)<i></br>\")\ndef list_initialization_misplaced():\n    for_loops = all_for_loops()\n    for loop in for_loops:\n        list_prop = loop.iter\n        if list_prop.data_type == \"List\" and def_use_error(list_prop):\n            explain(\"Initialization is a list but either wrong place or redefined<br><br><i>(list_init_misplaced)<i></br>\")\ndef missing_for_slot_empty():\n    for_loops = all_for_loops()\n    is_missing = False\n    for loop in for_loops:\n        list_prop = loop.iter\n        iter_prop = loop.target\n        if list_prop.ast_name == \"Name\" and list_prop.id == \"___\":\n            is_missing = True\n            break\n        if iter_prop.ast_name == \"Name\" and iter_prop.id == \"___\":\n            is_missing = True\n            break\n    if is_missing:\n        explain(\"You must fill in the empty slot in the iteration.<br><br><i>(for_incomplete)<i></br>\")\ndef wrong_target_reassigned():\n    ast = parse_program()\n    for_loops = all_for_loops()\n    is_reassigned = False\n    iter_props = []\n    for loop in for_loops:\n        iter_props.append(loop.target)\n    assignments = ast.find_all(\"Assign\")\n    off_prop = \"\"\n    for assignment in assignments:\n        left = assignment.targets\n        for iter_prop in iter_props:\n            if left.id == iter_prop.id:\n                off_prop = left.id\n                is_reassigned = True\n                break\n        if is_reassigned:\n            break\n    if is_reassigned:\n        explain(\"The property <code>%s</code> has been reassigned. The iteration property shouldn't be reassigned<br><br><i>(target_reassign)<i></br>\" %(off_prop))"
$INSTRUCTOR_MODULES_EXTENDED["instructor_printing.py"] = "from instructor import *\nfrom instructor_utility import *\n\ndef ensure_prints(count):\n    prints = find_function_calls('print')\n    if not prints:\n        gently(\"You are not using the print command!\")\n        return False\n    elif len(prints) > count:\n        gently(\"You are printing too many times!\")\n        return False\n    elif len(prints) < count:\n        gently(\"You are not printing enough things!\")\n        return False\n    else:\n        for a_print in prints:\n            if not is_top_level(a_print):\n                gently(\"You have a print statement that is not at the top level. That is incorrect!\")\n                return False\n    return prints\n"
$INSTRUCTOR_MODULES_EXTENDED["instructor_utility.py"] = "from instructor import *\n\ndef is_top_level(ast_node):\n    ast = parse_program()\n    for element in ast.body:\n        if element.ast_name == 'Expr':\n            if element.value == ast_node:\n                return True\n        elif element == ast_node:\n            return True\n    return False\n\ndef find_function_calls(name):\n    ast = parse_program()\n    all_calls = ast.find_all('Call')\n    calls = []\n    for a_call in all_calls:\n        if a_call.func.ast_name == 'Attribute':\n            if a_call.func.attr == name:\n                calls.append(a_call)\n        elif a_call.func.ast_name == 'Name':\n            if a_call.func.id == name:\n                calls.append(a_call)\n    return calls\n\ndef function_is_called(name):\n    return len(find_function_calls(name))\n    \ndef no_nonlist_nums():\n    pass\n    \ndef only_printing_variables():\n    ast = parse_program()\n    all_calls = ast.find_all('Call')\n    count = 0\n    for a_call in all_calls:\n        if a_call.func.ast_name == 'Name' and a_call.func.id == \"print\":\n            for arg in a_call.args:\n                if arg.ast_name != \"Name\":\n                    return False\n    return True\n\ndef find_prior_initializations(node):\n    if node.ast_name != \"Name\":\n        return None\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    cur_line_no = node.lineno\n    all_assignments = []\n    for assignment in assignments:\n        if assignment.has(node):\n            if assignment.lineno < cur_line_no:\n                all_assignments.append(assignment)\n    return all_assignments\n\n'''\n    \n    mod.no_nonlist_nums = new Sk.builtin.func(function(source) {\n        Sk.builtin.pyCheckArgs(\"no_nonlist_nums\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"source\", \"string\", Sk.builtin.checkString(source));\n        \n        source = source.v;\n        \n        var num_list = getNonListNums(source);\n        \n        var count = 0;\n        for (var i = 0, len = num_list.length; i < len; i = i+1) {\n            if (num_list[i].v != 0 && num_list[i].v != 1) {\n                return Sk.ffi.remapToPy(true);\n            }\n        }\n        return Sk.ffi.remapToPy(false);\n    });\n\n\n    \n    /**\n     * Given source code as a string, return a list of all of the AST elements\n     * that are Num (aka numeric literals) but that are not inside List elements.\n     *\n     * @param {String} source - Python source code.\n     * @returns {Array.number} The list of JavaScript numeric literals that were found.\n     */\n    function getNonListNums(source) {\n        if (!(source in parses)) {\n            var parse = Sk.parse(\"__main__\", source);\n            parses[source] = Sk.astFromParse(parse.cst, \"__main__\", parse.flags);\n        }\n        var ast = parses[source];\n        var visitor = new NodeVisitor();\n        var insideList = false;\n        var nums = [];\n        visitor.visit_List = function(node) {\n            insideList = true;\n            this.generic_visit(node);\n            insideList = false;\n        }\n        visitor.visit_Num = function(node) {\n            if (!insideList) {\n                nums.push(node.n);\n            }\n            this.generic_visit(node);\n        }\n        visitor.visit(ast);\n        return nums;\n    }\n    \n    \n '''"
$INSTRUCTOR_MODULES_EXTENDED["iteration_context.py"] = "from instructor_utility import *\nimport instructor_append as append_api\n#################8.2 Start#######################\ndef wrong_list_length_8_2():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    for assignment in assignments:\n        right = assignment.value\n        left = assignment.targets\n        if right.ast_name == \"List\" and left.ast_name == \"Name\":\n            if len(right.elts) < 3:\n                explain(\"You must have at least three pieces<br><br><i>(list length_8.2)<i></br>\")\ndef missing_list_initialization_8_2():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    isMissing = True\n    for assignment in assignments:\n        right = assignment.value\n        left = assignment.targets\n        if left.id == \"shopping_cart\":\n            if right.ast_name == \"List\":\n                isMissing = False\n                break\n    if isMissing:\n        explain(\"You must set the property <code>shopping_cart</code> to a list containing the prices of items in the shopping cart.<br><br><i>(missing_list_init_8.2)<i></br>\")\ndef wrong_list_is_constant_8_2():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    isNumber = False\n    for assignment in assignments:\n        right = assignment.value\n        left = assignment.targets\n        if left.id == \"shopping_cart\":\n            if right.ast_name == \"Num\":\n                isNumber = True\n                break\n    if isNumber:\n        explain(\"You must set <code>shoppping_cart</code> to a list of values not to a single number.<br><br><i>(list_is_const_8.2)<i></br>\")\ndef list_all_zeros_8_2():\n    ast = parse_program()\n    lists = ast.find_all(\"List\")\n    is_all_zero = True\n    for init_list in lists:\n        for node in init_list.elts:\n            if node.ast_name == \"Num\" and node.n != 0:\n                is_all_zero = False\n                break\n        if is_all_zero:\n            break\n    if is_all_zero:\n        explain(\"Try seeing what happens when you change the numbers in the list.<br><br><i>(default_list_8.2)<i></br>\")\n#################8.2 End#######################\n#################8.3 Start#######################\ndef wrong_list_initialization_placement_8_3():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    is_placed_wrong = True\n    lineno = None\n    for assignment in assignments:\n        right = assignment.value\n        left = assignment.targets\n        if left.id == \"episode_length_list\":\n            lineno = left.lineno\n    loops = ast.find_all(\"For\")\n    for loop in loops:\n        if loop.lineno > lineno:\n            is_placed_wrong = False\n    if is_placed_wrong:\n        explain(\"The list of episode lengths (<code>episode_length_list</code>) must be initialized before the iteration which uses this list.<br><br><i>(init_place_8.3)<i></br>\")\n    return True\ndef wrong_accumulator_initialization_placement_8_3():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    is_placed_wrong = True\n    lineno = None\n    for assignment in assignments:\n        right = assignment.value\n        left = assignment.targets\n        if left.id == \"sum_length\" and right.ast_name == \"Num\" and right.n == 0:\n            lineno = left.lineno\n    loops = ast.find_all(\"For\")\n    for loop in loops:\n        if lineno == None: \n            break\n        if loop.lineno > lineno:\n            is_placed_wrong = False\n    if is_placed_wrong:\n        explain(\"The property to hold the sum of the episode lengths (<code>sum_length</code>) must be initialized before the iteration which uses this property.<br><br><i>(accu_init_place_8.3)<i></br>\")\n    return is_placed_wrong \ndef wrong_iteration_body_8_3():\n    ast = parse_program()\n    is_placed_wrong = True\n    loops = ast.find_all(\"For\")\n    for loop in loops:\n        assignments = loop.find_all(\"Assign\")\n        for assignment in assignments:\n            right = assignment.value\n            left = assignment.targets\n            if left.id == \"sum_length\" and right.ast_name == \"BinOp\" and right.op == \"Add\":\n                is_placed_wrong = False\n    if is_placed_wrong:\n        explain(\"The addition of each episode length to the total length is not in the correct place.<br><br><i>(iter_body_8.3)<i></br>\")\n    return is_placed_wrong\ndef wrong_print_8_3():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    has_for = len(for_loops) > 0\n    for_loc = []\n    wrong_print_placement = True\n    for loop in for_loops:\n        end_node = loop.next_tree\n        if end_node != None:\n            for_loc.append(end_node.lineno)\n    calls = ast.find_all(\"Call\")\n    for call in calls:\n        if call.func.id == \"print\":\n            for loc in for_loc:\n                if call.func.lineno >= loc:\n                    wrong_print_placement = False\n                    break\n            if not wrong_print_placement:\n                break\n    if wrong_print_placement:\n        explain(\"The output of the total length of time is not in the correct place. The total length of time should be output only once after the total length of time has been computed.<br><br><i>(print_8.3)<i></br>\")\n\n#################8.3 End#######################\n#################8.4 Start#######################\ndef missing_target_slot_empty_8_4():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    for loop in for_loops:\n        iter_prop = loop.target\n        if iter_prop.id == \"___\":\n            explain(\"You must fill in the empty slot in the iteration.<br><br><i>(target_empty_8.4)<i></br>\")\n            return False\n    return True\ndef missing_addition_slot_empty_8_4():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    for assignment in assignments:\n        left = assignment.targets\n        right = assignment.value\n        if left.id == \"sum_pages\":\n            binOp = right.find_all(\"BinOp\")\n            if len(binOp) == 1:\n                binOp = binOp[0]\n                if binOp.op == \"Add\":\n                    if binOp.left.ast_name == \"Name\" and binOp.right.ast_name == \"Name\":\n                        if binOp.has(left):\n                            if binOp.left.id == \"___\" or binOp.right.id == \"___\":\n                                explain(\"You must fill in the empty slot in the addition.<br><br><i>(add_empty_8.4)<i></br>\")\n                                return True\n    return False\ndef wrong_names_not_agree_8_4():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    for loop in for_loops:\n        iter_prop = loop.target\n        list_prop = loop.iter\n        if list_prop.ast_name == \"Name\" and iter_prop.ast_name == \"Name\":\n            assignments = loop.find_all(\"Assign\")\n            for assignment in assignments:\n                binops = assignment.find_all(\"BinOp\")\n                if len(binops) > 0:\n                    lhs = assignment.targets\n                    if lhs.ast_name == \"Name\" and lhs.id == \"sum_pages\":\n                        for binop in binops:\n                            if binop.has(lhs) and binop.op == \"Add\":\n                                if not binop.has(iter_prop):\n                                    explain(\"Each value of <code>%s</code> must be added to <code>%s</code>.<br><br><i>(name_agree_8.4)<i></br>\" %(iter_prop.id, lhs.id))\n                                    return True\n    return False\n#################8.4 End#######################\ndef wrong_modifying_list_8_5():\n    ast = parse_program()\n    list_init = ast.find_all(\"List\")\n    true_sum = 0\n    for value in list_init[0].elts:\n        true_sum = value.n + true_sum\n    if true_sum != sum([20473, 27630, 17849, 19032, 16378]):\n        explain(\"Don't modify the list<br><br><i>(mod_list_8.5)<i></br>\")\ndef wrong_modifying_list_8_6():\n    ast = parse_program()\n    list_init = ast.find_all(\"List\")\n    true_sum = 0\n    for value in list_init[0].elts:\n        true_sum = value.n + true_sum\n    if true_sum != sum([2.9, 1.5, 2.3, 6.1]):\n        explain(\"Don't modify the list<br><br><i>(mod_list_8.6)<i></br>\")\ndef wrong_should_be_counting():#This doesn't do as it is intended to do!\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    for loop in for_loops:\n        iter_prop = loop.target\n        assignments = loop.find_all(\"Assign\")\n        for assignment in assignments:\n            binops = assignment.find_all(\"BinOp\")\n            for binop in binops:\n                if binop.has(iter_prop) and binop.op == \"Add\":\n                    explain(\"This problem asks for the number of items in the list not the total of all the values in the list.<br><br><i>(not_count)<i></br>\")\ndef wrong_should_be_summing():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    for loop in for_loops:\n        assignments = loop.find_all(\"Assign\")\n        for assignment in assignments:\n            binops = assignment.find_all(\"BinOp\")\n            for binop in binops:\n                if binop.has(1) and binop.op == \"Add\":\n                    explain(\"This problem asks for the total of all the values in the list not the number of items in the list.<br><br><i>(not_sum)<i></br>\")\ndef missing_addition_slot_empty():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    for assignment in assignments:\n        left = assignment.targets\n        right = assignment.value\n        binOp = right.find_all(\"BinOp\")\n        if len(binOp) == 1:\n            binOp = binOp[0]\n            if binOp.op == \"Add\":\n                if binOp.left.ast_name == \"Name\" and binOp.right.ast_name == \"Name\":\n                    if binOp.left.id == \"___\" or binOp.right.id == \"___\":\n                        explain(\"You must fill in the empty slot in the addition.<br><br><i>(add_empty)<i></br>\")\n                        return True\n    return False\ndef wrong_cannot_sum_list():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    for loop in for_loops:\n        list_prop = loop.iter\n        assignments = loop.find_all(\"Assign\")\n        for assignment in assignments:\n            binops = assignment.find_all(\"BinOp\")\n            for binop in binops:\n                if binop.has(list_prop) and binop.op == \"Add\":\n                    explain(\"Addition can only be done with a single value at a time, not with an entire list at one time.<br><br><i>(sum_list)<i></br>\")\ndef missing_no_print():\n    prints = find_function_calls('print')\n    if not prints:\n        explain(\"Program does not output anything.<br><br><i>(no_print)<i></br>\")\ndef missing_counting_list():\n    ast = parse_program()\n    has_count = False\n    for_loops = ast.find_all(\"For\")\n    if len(for_loops) > 0:\n        for loop in for_loops:\n            assignments = loop.find_all(\"Assign\")\n            if len(assignments) < 1:\n                continue\n            for assignment in assignments:\n                binops = assignment.find_all(\"BinOp\")\n                if len(binops) < 1:\n                    continue\n                lhs = assignment.targets\n                for binop in binops:\n                    if binop.has(lhs) and binop.has(1) and binop.op == \"Add\":\n                        has_count = True\n    if not has_count:\n        explain(\"Need to find the total number of items in the list.<br><br><i>(miss_count_list)<i></br>\")\ndef missing_summing_list():\n    ast = parse_program()\n    has_total = False\n    for_loops = ast.find_all(\"For\")\n    if len(for_loops) > 0:\n        for loop in for_loops:\n            assignments = loop.find_all(\"Assign\")\n            if len(assignments) < 1:\n                continue\n            iter_prop = loop.target\n            for assignment in assignments:\n                binops = assignment.find_all(\"BinOp\")\n                if len(binops) < 1:\n                    continue\n                lhs = assignment.targets\n                for binop in binops:\n                    if binop.has(lhs) and binop.has(iter_prop) and binop.op == \"Add\":\n                        has_total = True\n    if not has_total:\n        explain(\"Need to find the total of all list elements.<br><br><i>(miss_sum_list)<i></br>\")\ndef missing_zero_initialization():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    accumulator = None\n    loop_acu = None\n    for loop in for_loops:\n        assignments = loop.find_all(\"Assign\")\n        for assignment in assignments:\n            binops = assignment.find_all(\"BinOp\")\n            if len(binops) > 0:\n                lhs = assignment.targets\n                for binop in binops:\n                    if binop.has(lhs) and binop.op == \"Add\":\n                        accumulator = lhs\n                        loop_acu = loop\n    accu_init = False\n    if accumulator != None:\n        assignments = ast.find_all(\"Assign\")\n        for assignment in assignments:\n            if loop_acu.lineno > assignment.lineno:\n                lhs = assignment.targets\n                if lhs.id == accumulator.id and assignment.has(0):\n                    accu_init = True\n                    break\n    if accu_init == False and accumulator != None:\n        explain(\"The addition on the first iteration step is not correct because either the property <code>%s</code> has not been initialized to an appropriate initial value or it has not been placed in an appropriate location<br><br><i>(miss_zero_init)<i></br>\" %(accumulator.id))\n        return False\n    return True\ndef wrong_printing_list():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    calls = ast.find_all(\"Call\")\n    log(calls)\n    for call in calls:\n        if call.func.id == \"print\":\n            if call.args[0].ast_name == \"Name\" and call.args[0].data_type != \"Num\":\n                explain(\"You should be printing a single value.<br><br><i>(list_print)<i></br>\")\n#################AVERAGE START###############\n'''\ndef missing_average():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    has_for = len(for_loops) > 0\n    has_average = False\n    for_loc = []\n    for loop in for_loops:\n        end_node = loop.next_tree\n        if end_node != None:\n            for_loc.append(end_node.lineno)\n    if has_for:\n        assignments = ast.find_all(\"Assign\")\n        if len(assignments) > 0:\n            for assignment in assignments:\n                binops = assignment.find_all(\"BinOp\")\n                lhs = assignment.targets\n                if len(binops) != 1:\n                    continue\n                binop = binops[0]\n                if binop.op != \"Div\":\n                    continue\n                is_after = False\n                for lineno in for_loc:\n                    if lineno <= binop.lineno:\n                        is_after = True\n                        break\n                if not is_after:\n                    break\n                right = binop.right\n                left = binop.left\n                if right.ast_name == \"Name\" and left.ast_name == \"Name\":\n                    if right.id != left.id and right.id != lhs.id and left.id != lhs.id:\n                        has_average = True\n                        break\n    if not has_average:\n        explain(\"An average value is not computed.<br><br><i>(no_avg)<i></br>\")\n'''\ndef missing_average():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    has_for = len(for_loops) > 0\n    has_average = False\n    for_loc = []\n    for loop in for_loops:\n        end_node = loop.next_tree\n        if end_node != None:\n            for_loc.append(end_node.lineno)\n    if has_for:\n        binops = ast.find_all(\"BinOp\")\n        for binop in binops:\n            if binop.op != \"Div\":\n                continue\n            is_after = False\n            for lineno in for_loc:\n                if lineno <= binop.lineno:\n                    is_after = True\n                    break\n            if not is_after:\n                break\n            right = binop.right\n            left = binop.left\n            if right.ast_name == \"Name\" and left.ast_name == \"Name\":\n                if right.id != left.id:\n                    has_average = True\n                    break\n    if not has_average:\n        explain(\"An average value is not computed.<br><br><i>(no_avg)<i></br>\")\ndef warning_average_in_iteration():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    for loop in for_loops:\n        assignments = loop.find_all(\"Assign\")\n        for assignment in assignments:\n            binops = assignment.find_all(\"BinOp\")\n            for binop in binops:\n                if binop.op == \"Div\":\n                    assName = assignment.targets\n                    numerator = binop.left\n                    denominator = binop.right\n                    if numerator.ast_name == \"Name\" and denominator.ast_name == \"Name\":\n                        explain(\"An average value is best computed after the properties name <code>%s</code>(total) and <code>%s</code> are completely known rather than recomputing the average on each iteration.<br><br><i>(avg_in_iter)<i></br>\" %(numerator.id,denominator.id))\ndef wrong_average_denominator():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    count_vars = []\n    loc_array = []\n    for loop in for_loops:\n        iter_prop = loop.target\n        end_node = loop.next_tree\n        if end_node == None:\n            continue\n        loc = end_node.lineno\n        assignments = loop.find_all(\"Assign\")\n        for assignment in assignments:\n            if assignment.has(1):\n                ass_left = assignment.targets\n                ass_right = assignment.value\n                if ass_right.ast_name == \"BinOp\" and ass_right.op == \"Add\":\n                    if ass_right.has(ass_left):\n                        count_vars.append(ass_left)\n                        loc_array.append(loc)\n    assignments = ast.find_all(\"Assign\")\n    denominator_wrong = False\n    for assignment in assignments:\n        index = 0\n        for loc in loc_array:\n            if assignment.lineno >= loc and assignment.value.ast_name == \"BinOp\":\n                ass_left = assignment.targets\n                binop = assignment.value\n                if binop.op == \"Div\" and not binop.has(ass_left):\n                    numerator = assignment.value.left\n                    denominator = assignment.value.right\n                    if numerator.id != denominator.id and denominator.id != count_vars[index].id:\n                        denominator_wrong = True\n            if denominator_wrong:\n                break\n            index = index + 1\n        if denominator_wrong:\n            break\n    if denominator_wrong:\n        explain(\"The average is not calculated correctly.<br><br><i>(avg_denom)<i></br>\")\n    return denominator_wrong\ndef wrong_average_numerator():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    total_vars = []\n    loc_array = []\n    for loop in for_loops:\n        iter_prop = loop.target\n        end_node = loop.next_tree\n        if end_node == None:\n            continue\n        loc = end_node.lineno\n        assignments = loop.find_all(\"Assign\")\n        for assignment in assignments:\n            if assignment.has(iter_prop):\n                ass_left = assignment.targets\n                ass_right = assignment.value\n                if ass_right.ast_name == \"BinOp\" and ass_right.op == \"Add\":\n                    if ass_right.has(ass_left):\n                        total_vars.append(ass_left)\n                        loc_array.append(loc)\n    assignments = ast.find_all(\"Assign\")\n    numerator_wrong = False\n    for assignment in assignments:\n        index = 0\n        for loc in loc_array:\n            if assignment.lineno >= loc and assignment.value.ast_name == \"BinOp\":\n                ass_left = assignment.targets\n                binop = assignment.value\n                if binop.op == \"Div\" and not binop.has(ass_left):\n                    numerator = assignment.value.left\n                    denominator = assignment.value.right\n                    if numerator.id != denominator.id and numerator.id != total_vars[index].id:\n                        numerator_wrong = True\n            if numerator_wrong:\n                break\n            index = index + 1\n        if numerator_wrong:\n            break\n    if numerator_wrong:\n        explain(\"The average is not calculated correctly.<br><br><i>(avg_numer)<i></br>\")\n    return numerator_wrong\n########################AVERAGE END###########################\ndef wrong_compare_list():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    is_comparing_list = False\n    offending_list = \"\"\n    for loop in for_loops:\n        list_prop = loop.iter\n        ifs = ast.find_all(\"If\")\n        for if_block in ifs:\n            if if_block.test.has(list_prop):\n                is_comparing_list = True\n                offending_list = list_prop.id\n                break\n        if is_comparing_list:\n            break\n    if is_comparing_list:\n        explain(\"Each item in the list <code>%s</code> must be compared one item at a time.<br><br><i>(comp_list)<i></br>\" %(offending_list))\n    return is_comparing_list\ndef wrong_for_inside_if():\n    ast = parse_program()\n    if_blocks = ast.find_all(\"If\")\n    if_inside_for = False\n    for if_block in if_blocks:\n        loops = if_block.find_all(\"For\")\n        if len(loops) > 0:\n            if_inside_for = True\n            break\n    if if_inside_for:\n        explain(\"The iteration should not be inside the decision block.<br><br><i>(for_in_if)<i></br>\")\n    return if_inside_for\ndef iterator_is_function():\n    ast = parse_program()\n    for_loops = all_for_loops()\n    for loop in for_loops:\n        list_prop = loop.iter\n        if list_prop.ast_name == \"Call\":\n            explain(\"You should make a property for the list instead of using a function call for the list<br><br><i>(iter_is_func)<i></br>\")\n###########################9.1 START############################\ndef wrong_list_initialization_9_1():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    has_call = False\n    for assignment in assignments:\n        if assignment.targets.id == \"rainfall_list\":\n            call = assignment.find_all(\"Call\")\n            if len(call) == 1:\n                args = call[0].args\n                if len(args) == 3:\n                    if args[0].s == \"Precipitation\" and args[1].s == \"Location\" and args[2].s == \"Blacksburg, VA\":\n                        has_call = True\n                        break\n    if not has_call:\n        explain(\"The list of rainfall amounts (<code>rainfall_list</code>) is not initialized properly.<br><br><i>(list_init_9.1)<i></br>\")\n    return not has_call\ndef wrong_accumulator_initialization_9_1():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    has_assignment = False\n    for assignment in assignments:\n        if assignment.targets.id == \"rainfall_sum\" and assignment.value.ast_name == \"Num\":\n            if assignment.value.n == 0:\n                has_assignment = True\n                break\n    if not has_assignment:\n        explain(\"The property to hold the total value of the rainfall amounts (<code>rainfall_sum</code>) is not initialized properly.<br><br><i>(accu_init_9.1)<i></br>\")\n    return not has_assignment\ndef wrong_accumulation_9_1():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    has_assignment = False\n    for assignment in assignments:\n        target = assignment.targets\n        if target.id == \"rainfall_sum\":\n            if assignment.value.ast_name == \"BinOp\":\n                binop = assignment.value\n                if binop.op == \"Add\":\n                    left = binop.left\n                    right = binop.right\n                    if (left.id == \"rainfall_sum\" or right.id == \"rainfall_sum\") and (left.id == \"rainfall\" or right.id == \"rainfall\"):\n                        has_assignment = True\n                        break\n    if not has_assignment:\n        explain(\"The addition of each rainfall amount to <code>rainfall_sum</code> is not correct.<br><br><i>(accu_9.1)<i></br>\")\n    return not has_assignment\ndef wrong_list_initialization_placement_9_1():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    loops = ast.find_all(\"For\")\n    list_init = None\n    init_after_loop = False\n    for assignment in assignments:\n        if assignment.targets.id == \"rainfall_list\":\n            list_init = assignment\n            break\n    if list_init != None:\n        for loop in loops:\n            if loop.lineno > list_init.lineno:\n                init_after_loop = True\n                break\n    if list_init == None or not init_after_loop:\n        explain(\"The list of rainfall amount (<code>rainfall_list</code>) must be initialized before the iteration that uses this list.<br><br><i>(list_init_place_9.1)<i></br>\")\ndef wrong_accumulator_initialization_placement_9_1():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    loops = ast.find_all(\"For\")\n    list_init = None\n    init_after_loop = False\n    for assignment in assignments:\n        if assignment.targets.id == \"rainfall_sum\":\n            list_init = assignment\n            break\n    for loop in loops:\n        if list_init != None and loop.lineno > list_init.lineno:\n            init_after_loop = True\n            break\n    if list_init == None or not init_after_loop:\n        explain(\"The property for the sum of all the rainfall amounts (<code>rainfall_sum</code>) must be initialized before the iteration which uses this property.<br><br><i>(accu_init_place_9.1)<i></br>\")\ndef wrong_iteration_body_9_1():\n    ast = parse_program()\n    loops = ast.find_all(\"For\")\n    assignment_in_for = False\n    for loop in loops:\n        assignments = loop.find_all(\"Assign\")\n        for assignment in assignments:\n            if assignment.targets.id == \"rainfall_sum\":\n                assignment_in_for = True\n                break\n        if assignment_in_for:\n            break\n    if not assignment_in_for:\n        explain(\"The addition of each rainfall amount to the total rainfall is not in the correct place.<br><br><i>(iter_body_9.1)<i></br>\")\ndef wrong_print_9_1():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    has_for = len(for_loops) > 0\n    for_loc = []\n    wrong_print_placement = True\n    for loop in for_loops:\n        end_node = loop.next_tree\n        if end_node != None:\n            for_loc.append(end_node.lineno)\n    calls = ast.find_all(\"Call\")\n    for call in calls:\n        if call.func.id == \"print\":\n            for loc in for_loc:\n                if call.func.lineno >= loc:\n                    wrong_print_placement = False\n                    break\n            if not wrong_print_placement:\n                break\n    if wrong_print_placement:\n        explain(\"The output of the total rainfall amount is not in the correct place. The total rainfall should be output only once after the total rainfall has been computed.<br><br><i>(print_9.1)<i></br>\")\n###########################9.1 END############################\n###########################9.2 START############################\ndef wrong_list_initialization_9_2():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    has_call = False\n    for assignment in assignments:\n        if assignment.targets.id == \"rainfall_list\":\n            call = assignment.find_all(\"Call\")\n            if len(call) == 1:\n                args = call[0].args\n                if len(args) == 3:\n                    if args[0] == \"Precipitation\" and args[1] == \"Location\" and args[2] == \"Blacksburg, VA\":\n                        has_call = True\n                        break\n    if not has_call:\n        explain(\"The list of rainfall amounts (<code>rainfall_list</code>) is not initialized properly.<br><br><i>(list_init_9.2)<i></br>\")\n    return not has_call\ndef wrong_accumulator_initialization_9_2():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    has_assignment = False\n    for assignment in assignments:\n        if assignment.targets.id == \"rainfall_count\" and assignment.value.ast_name == \"Num\":\n            if assignment.value.n == 0:\n                has_assignment = True\n                break\n    if not has_assignment:\n        explain(\"The property to hold the total value of the rainfall amounts (<code>rainfall_count</code>) is not initialized properly.<br><br><i>(accu_init_9.2)<i></br>\")\n    return not has_assignment\ndef wrong_accumulation_9_2():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    has_assignment = False\n    for assignment in assignments:\n        target = assignment.targets\n        if target.id == \"rainfall_count\":\n            if assignment.value.ast_name == \"BinOp\":\n                binop = assignment.value\n                if binop.op == \"Add\":\n                    left = binop.left\n                    right = binop.right\n                    if (left.id == \"rainfall_count\" or right.id == \"rainfall_count\") and (left.ast_name == \"Num\" or right.ast_name == \"Num\"):\n                        if left.ast_name == \"Num\":\n                            num_node = left\n                        else:\n                            num_node = right\n                        if num_node.n == 1:\n                            has_assignment = True\n                        break\n    if not has_assignment:\n        explain(\"The adding of another day with rainfall to the total count of days with rainfall (<code>rainfall_count</code>) is not correct.<br><br><i>(accu_9.2)<i></br>\")\n    return not has_assignment\ndef wrong_list_initialization_placement_9_2():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    loops = ast.find_all(\"For\")\n    list_init = None\n    init_after_loop = False\n    for assignment in assignments:\n        if assignment.targets.id == \"rainfall_list\":\n            list_init = assignment\n            break\n    for loop in loops:\n        if list_init != None and loop.lineno > list_init.lineno:\n            init_after_loop = True\n            break\n    if list_init == None or not init_after_loop:\n        explain(\"The list of rainfall amount (<code>rainfall_list</code>) must be initialized before the iteration that uses this list.<br><br><i>(list_init_place_9.2)<i></br>\")\ndef wrong_accumulator_initialization_placement_9_2():\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    loops = ast.find_all(\"For\")\n    list_init = None\n    init_after_loop = False\n    for assignment in assignments:\n        if assignment.targets.id == \"rainfall_count\":\n            list_init = assignment\n            break\n    if list_init != None:\n        for loop in loops:\n            if loop.lineno > list_init.lineno:\n                init_after_loop = True\n                break\n    if list_init == None or not init_after_loop:\n        explain(\"The property for the count of the number of days having rain (<code>rainfall_count</code>) must be initialized before the iteration which uses this property.<br><br><i>(accu_init_place_9.2)<i></br>\")\ndef wrong_iteration_body_9_2():\n    ast = parse_program()\n    loops = ast.find_all(\"For\")\n    correct_if = False\n    for loop in loops:\n        if_blocks = loop.find_all(\"If\")\n        for if_block in if_blocks:\n            test = if_block.test\n            if test.numeric_logic_check(1, \"var > 0\"):\n                correct_if = True\n                break\n        if correct_if:\n            break\n    if not correct_if:\n        explain(\"The test (if) to determine if a given amount of rainfall is greater than (>) zero is not in the correct place.<br><br><i>(iter_body_9.2)<i></br>\")\n    return not correct_if\ndef wrong_decision_body_9_2():\n    ast = parse_program()\n    if_blocks = ast.find_all(\"If\")\n    assignment_in_if = False\n    for if_block in if_blocks:\n        test = if_block.test\n        if test.numeric_logic_check(1, \"var > 0\"):\n            assignments = if_block.find_all(\"Assign\")\n            for assignment in assignments:\n                if assignment.targets.id == \"rainfall_count\":\n                    if assignment.value.ast_name == \"BinOp\":\n                        binop = assignment.value\n                        if binop.has(1) and binop.has(assignment.targets):\n                            assignment_in_if = True\n                            break\n        if assignment_in_if:\n            break\n    if not assignment_in_if:\n        explain(\"The increase by 1 in the number of days having rainfall (<code>rainfall_count</code>) is not in the correct place.<br><br><i>(dec_body_9.2)<i></br>\")\ndef wrong_print_9_2():\n    ast = parse_program()\n    for_loops = ast.find_all(\"For\")\n    has_for = len(for_loops) > 0\n    for_loc = []\n    wrong_print_placement = True\n    for loop in for_loops:\n        end_node = loop.next_tree\n        if end_node != None:\n            for_loc.append(end_node.lineno)\n    calls = ast.find_all(\"Call\")\n    for call in calls:\n        if call.func.id == \"print\":\n            for loc in for_loc:\n                if call.func.lineno >= loc:\n                    wrong_print_placement = False\n                    break\n            if not wrong_print_placement:\n                break\n    if wrong_print_placement:\n        explain(\"The output of the total number of days with rainfall is not in the correct place. The total number of days should be output only once after the total number of days has been computed.<br><br><i>(print_9.2)<i></br>\")\n    return wrong_print_placement\n###########################9.2 END############################\n###########################9.6 START############################\ndef wrong_comparison_9_6():\n    ast = parse_program()\n    if_blocks = ast.find_all(\"If\")\n    if_error = False\n    for if_block in if_blocks:\n        if not if_block.has(80):\n            if_error = True\n            break\n        elif not if_block.test.numeric_logic_check(1, \"var > 80\"):\n            if_error = True\n            break\n    if if_error:\n        explain(\"In this problem you should be finding temperatures above 80 degrees.<br><br><i>(comp_9.6)<i></br>\")\n    return if_error\n###########################9.6 END############################\n###########################10.2 START############################\ndef wrong_conversion_10_2():\n    ast = parse_program()\n    loops = ast.find_all(\"For\")\n    has_conversion = False\n    conversion_var = \"\"\n    for loop in loops:\n        binops = loop.find_all(\"BinOp\")\n        iter_prop = loop.target\n        conversion_var = iter_prop.id\n        for binop in binops:\n            if binop.has(iter_prop) and binop.has(0.04) and binop.op == \"Mult\":\n                conversion_var = iter_prop.id\n                has_conversion = True\n                break\n    if conversion_var != \"\" and not has_conversion:\n        explain(\"The conversion of <code>%s</code> to inches is not correct.<br><br><i>(conv_10.2)<i></br>\" %(conversion_var))\n###########################10.2 END############################\n###########################10.3 START############################\ndef wrong_filter_condition_10_3():\n    ast = parse_program()\n    loops = ast.find_all(\"For\")\n    correct_if = False\n    for loop in loops:\n        if_blocks = loop.find_all(\"If\")\n        for if_block in if_blocks:\n            test = if_block.test\n            if test.numeric_logic_check(1, \"var > 0\") or test.numeric_logic_check(1, \"var != 0\"):\n                correct_if = True\n                break\n    if not correct_if:\n        explain(\"The condition used to filter the year when artists died is not correct.<br><br><i>(filt_10.3)<i></br>\")\n    return not correct_if\n###########################10.3 END############################\n###########################10.4 START############################\ndef wrong_and_filter_condition_10_4():\n    ast = parse_program()\n    loops = ast.find_all(\"For\")\n    correct_if = False\n    for loop in loops:\n        if_blocks = loop.find_all(\"If\")\n        for if_block in if_blocks:\n            test = if_block.test\n            if test.numeric_logic_check(1, \"32 <= temp && temp <= 50\"):\n                correct_if = True\n                break\n    if not correct_if:\n        explain(\"The condition used to filter the temperatures into the specified range of temperatures is not correct.<br><br><i>(filt_and_10.4)<i></br>\")\n    return not correct_if\ndef wrong_nested_filter_condition_10_4():\n    ast = parse_program()\n    loops = ast.find_all(\"For\")\n    correct_if = False\n    for loop in loops:\n        if_blocks = loop.find_all(\"If\")\n        for if_block in if_blocks:\n            test1 = if_block.test\n            if_blocks2 = if_block.find_all(\"If\")\n            for if_block2 in if_blocks2:\n                test2 = if_block2.test\n                if test1.numeric_logic_check(1, \"32 <= temp\") and test2.numeric_logic_check(1,\"temp <= 50\"):\n                    correct_if = True\n                    break\n                elif test2.numeric_logic_check(1, \"32 <= temp\") and test1.numeric_logic_check(1,\"temp <= 50\"):\n                    correct_if = True\n                    break\n    if not correct_if:\n        explain(\"The decisions used to filter the temperatures into the specified range of temperatures is not correct.<br><br><i>(nest_filt_10.4)<i></br>\")\n    return not correct_if\n###########################10.4 END############################\n#########################10.5 START###############################\ndef wrong_conversion_problem_10_5():\n    ast = parse_program()\n    loops = ast.find_all(\"For\")\n    is_wrong_conversion = False\n    for loop in loops:\n        iter_prop = loop.target\n        binops = loop.find_all(\"BinOp\")\n        for binop in binops:\n            if not (binop.op == \"Mult\" and binop.has(iter_prop) and binop.has(0.62)):\n                is_wrong_conversion = True\n                break\n        if is_wrong_conversion:\n            break\n    if is_wrong_conversion:\n        log(\"wrong_conversion_problem_10_5\")\n        explain(\"The conversion from kilometers to miles is not correct.<br><br><i>(conv_10.5)<i></br>\")\ndef wrong_filter_problem_atl1_10_5():\n    ast = parse_program()\n    loops = ast.find_all(\"For\")\n    correct_filter = False\n    for loop in loops:\n        iter_prop = loop.target\n        if_blocks = loop.find_all(\"If\")\n        for if_block in if_blocks:\n            cond = if_block.test\n            append_list = append_api.find_append_in(if_block)\n            for append in append_list:\n                expr = append.args[0]\n                #this check seens unnecessary\n                if expr.ast_name == \"BinOp\" and expr.op == \"Mult\" and expr.has(0.62) and expr.has(iter_prop):\n                    if not cond.numeric_logic_check(0.1, \"var * 0.62 > 10\"):\n                        log(\"wrong_filter_problem_atl1_10_5\")\n                        explain(\"You are not correctly filtering out values from the list.<br><br><i>(filt_alt1_10.5)<i></br>\")\ndef wrong_filter_problem_atl2_10_5():\n    ast = parse_program()\n    loops = ast.find_all(\"For\")\n    correct_filter = False\n    for loop in loops:\n        iter_prop = loop.target\n        assignments = loop.find_all(\"Assign\")\n        if_blocks = loop.find_all(\"If\")\n        for assignment in assignments:\n            for if_block in if_blocks:\n                if if_block.lineno > assignment.lineno:\n                    miles = assignment.targets\n                    expr = assignment.value\n                    cond = if_block.test\n                    append_list = append_api.find_append_in(if_block)\n                    for append in append_list:\n                        if append.has(miles):\n                            if expr.ast_name == \"BinOp\" and expr.op == \"Mult\" and expr.has(0.62) and expr.has(iter_prop):\n                                if not cond.numeric_logic_check(0.1, \"var > 10\"):\n                                    explain(\"You are not correctly filtering out values from the list.<br><br><i>(filt_alt2_10.5)<i></br>\")\ndef wrong_append_problem_atl1_10_5():\n    ast = parse_program()\n    loops = ast.find_all(\"For\")\n    correct_filter = False\n    for loop in loops:\n        iter_prop = loop.target\n        if_blocks = loop.find_all(\"If\")\n        for if_block in if_blocks:\n            cond = if_block.test\n            append_list = append_api.find_append_in(if_block)\n            for append in append_list:\n                expr = append.args[0]\n                #this is an approximation of what's written in the code because we don't have tree matching\n                cond_binops = cond.find_all(\"BinOp\")\n                if len(cond_binops) == 1:\n                    if not (expr.ast_name == \"BinOp\" and expr.op == \"Mult\" and expr.has(0.62) and expr.has(iter_prop)):\n                        #if not cond.numeric_logic_check(0.1, \"var * 0.62 > 10\"):#in theory should check this\n                        explain(\"You are not appending the correct values.<br><br><i>(app_alt1_10.5)<i></br>\")\ndef wrong_append_problem_atl2_10_5():\n    ast = parse_program()\n    loops = ast.find_all(\"For\")\n    correct_filter = False\n    for loop in loops:\n        iter_prop = loop.target\n        assignments = loop.find_all(\"Assign\")\n        if_blocks = loop.find_all(\"If\")\n        for assignment in assignments:\n            for if_block in if_blocks:\n                if if_block.lineno > assignment.lineno:\n                    miles = assignment.targets\n                    expr = assignment.value\n                    cond = if_block.test\n                    append_list = append_api.find_append_in(if_block)\n                    for append in append_list:\n                        append_var = append.args[0]\n                        if expr.ast_name == \"BinOp\" and expr.op == \"Mult\" and expr.has(0.62) and expr.has(iter_prop):\n                            if cond.numeric_logic_check(0.1, \"var > 10\"):\n                                if append_var.ast_name == \"Name\" and append_var.id != miles.id:\n                                    explain(\"You are not appending the correct values<br><br><i>(app_alt2_10.5)<i></br>\")\n#########################10.5 END###############################\ndef wrong_debug_10_6():\n    ast = parse_program()\n    #cheating because using length of 1\n    loops = ast.find_all(\"For\")\n    bad_change = False\n    if len(loops) != 1:\n        bad_change = True\n    else:\n        append_calls = append_api.find_append_in(loops[0])\n        if len(append_calls) != None:\n            bad_change = True\n    if not bad_change:\n        item = loops[0].target\n        list1 = loops[0].iter\n        list2 = append_calls[0].func.value.id\n        if list1.id != \"quakes\" or list2.id != \"quakes_in_miles\":\n            bad_change = True\n    if bad_change:\n        explain(\"This is not one of the two changes needed. Undo the change and try again.<br><br><i>(debug_10.6)<i></br>\")\ndef wrong_debug_10_7():\n    ast = parse_program()\n    if_blocks = ast.find_all(\"If\")\n    if len(if_blocks) > 1 or if_blocks[0].test.left.id != \"book\":\n        explain(\"This is not the change needed. Undo the change and try again.<br><br><i>(debug_10.7)<i></br>\")\n#########################PLOTTING###############################\ndef plot_group_error():\n    output = get_output()\n    if len(output) > 1:\n        explain(\"You should only be printing/plotting one thing!<br><br><i>(print_one)<i></br>\")\n        return True\n    elif len(output) == 0:\n        explain(\"The algorithm is plotting an empty list. Check your logic.<br><br><i>(blank_plot)<i></br>\")\n        return True\n    elif not isinstance(output[0], list):\n        explain(\"You should be plotting, not printing!<br><br><i>(printing)<i></br>\")\n        return True\n    elif len(output[0]) != 1:\n        explain(\"You should only be plotting one thing!<br><br><i>(one_plot)<i></br>\")\n        return True\ndef all_labels_present():\n    x_labels = len(find_function_calls(\"xlabel\"))\n    y_labels = len(find_function_calls(\"ylabel\"))\n    titles = len(find_function_calls(\"title\"))\n    if x_labels < 1 or y_labels < 1 or titles < 1:\n        explain(\"Make sure you supply labels to all your axes and provide a title\")\n        return False\n    return True\n"
